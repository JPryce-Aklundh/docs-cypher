:description: Information about quantified path patterns, quantified relationships, and group variables.
= Variable length patterns

Cypher can be used to match patterns of a variable or an unknown length.
Such patterns can be found using quantified path patterns and quantified relationships.
This page also discusses how variables work when declared in quantified path patterns (group variables), and how to use predicates in quantified path patterns.

[[quantified-path-patterns]]
== Quantified path patterns 
_This feature was introduced in Neo4j 5.9._

This section considers how to match paths of _varying_ length by using _quantified path patterns_, allowing you to search for paths whose lengths are unknown or within a specific range.

Quantified path patterns can be useful when, for example, searching for all nodes that can be reached from an anchor node, finding all paths connecting two nodes, or when traversing a hierarchy that may have differing depths.

This example uses a new graph:

image::patterns_qpp_calling_points.svg[width="700",role="middle"]

To recreate the graph, run the following query against an empty Neo4j database:

[source, cypher, role=test-setup]
----
CREATE (pmr:Station {name: 'Peckham Rye'}),
  (dmk:Station {name: 'Denmark Hill'}),
  (clp:Station {name: 'Clapham High Street'}),
  (wwr:Station {name: 'Wandsworth Road'}),
  (clj:Station {name: 'Clapham Junction'}),
  (s1:Stop {arrives: time('17:19'), departs: time('17:20')}),
  (s2:Stop {arrives: time('17:12'), departs: time('17:13')}),
  (s3:Stop {arrives: time('17:10'), departs: time('17:11')}),
  (s4:Stop {arrives: time('17:06'), departs: time('17:07')}),
  (s5:Stop {arrives: time('16:58'), departs: time('17:01')}),
  (s6:Stop {arrives: time('17:17'), departs: time('17:20')}),
  (s7:Stop {arrives: time('17:08'), departs: time('17:10')}),
  (clj)<-[:CALLS_AT]-(s1), (wwr)<-[:CALLS_AT]-(s2),
  (clp)<-[:CALLS_AT]-(s3), (dmk)<-[:CALLS_AT]-(s4),
  (pmr)<-[:CALLS_AT]-(s5), (clj)<-[:CALLS_AT]-(s6),
  (dmk)<-[:CALLS_AT]-(s7),
  (s5)-[:NEXT {distance: 1.2}]->(s4),(s4)-[:NEXT {distance: 0.34}]->(s3),
  (s3)-[:NEXT {distance: 0.76}]->(s2), (s2)-[:NEXT {distance: 0.3}]->(s1),
  (s7)-[:NEXT {distance: 1.4}]->(s6)
----

Each `Stop` on a service `CALLS_AT` one `Station`.
Each `Stop` has the properties `arrives` and `departs` that give the times the train is at the `Station`.
Following the `NEXT` relationship of a `Stop` will give the next `Stop` of the service.

For this example, a path pattern is constructed to match each of the services that allow passengers to travel from `Denmark Hill` to `Clapham Junction`.
The following shows the two paths that the path pattern should match:

image::patterns_qpp_solutions.svg[width="700",role="middle"]

The following motif represents a fixed-length path pattern that matches the service that departs from `Denmark Hill` station at `17:07`:

image::patterns_qpp_motif1.svg[width="700",role="middle"]

To match the second train service, leaving `Denmark Hill` at `17:10`, a shorter path pattern is needed:

image::patterns_qpp_motif2.svg[width="400",role="middle"]

Translating the motifs into Cypher, and adding predicates to match the origin and destination `Stations`, yields the following two path patterns respectively:

[source, role=noheader]
----
(:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(:Stop)
  -[:NEXT]->(:Stop)
  -[:NEXT]->(:Stop)
  -[:NEXT]->(:Stop)-[:CALLS_AT]->
(:Station { name: 'Clapham Junction' })
----

[source, role=noheader]
----
(:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(:Stop)
  -[:NEXT]->(:Stop)-[:CALLS_AT]->
(:Station { name: 'Clapham Junction' })
----

To return both solutions in the same query using these fixed-length path patterns, a xref:clauses/union.adoc[UNION] of two `MATCH` statements would be needed.
For example, the following query returns the `departure` of the two services:

.Query
[source, cypher]
----
MATCH (:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(d:Stop)
        -[:NEXT]->(:Stop)
        -[:NEXT]->(:Stop)
        -[:NEXT]->(a:Stop)-[:CALLS_AT]->
      (:Station { name: 'Clapham Junction' })
RETURN d.departs AS departureTime, a.arrives AS arrivalTime
UNION
MATCH (:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(d:Stop)
        -[:NEXT]->(a:Stop)-[:CALLS_AT]->
      (:Station { name: 'Clapham Junction' })
RETURN d.departs AS departureTime, a.arrives AS arrivalTime
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| departureTime | arrivalTime

| "17:07:00Z" | "17:19:00Z"
| "17:10:00Z" | "17:17:00Z"

2+d|Rows: 2

|===

The problem with this solution is that not only is it verbose, it can only be used where the lengths of the target paths are known in advance.
Quantified path patterns solve this problem by extracting repeating parts of a path pattern into parentheses and applying a *quantifier*.
That quantifier specifies a range of possible repetitions of the extracted pattern to match on.
For the current example, the first step is identifying the repeating pattern, which in this case is the sequence of alternating `Stop` nodes and `NEXT` relationships, representing one segment of a `Service`:

[source, role=noheader]
----
(:Stop)-[:NEXT]->(:Stop)
----

The shortest path has one instance of this pattern, the longest three.
So the quantifier applied to the wrapper parentheses is the range one to three, expressed as `{1,3}`:

[source, role=noheader]
----
((:Stop)-[:NEXT]->(:Stop)){1,3}
----

This also includes repetitions of two, but in this case this repetition will not return matches.
To understand the semantics of this pattern, it helps to work through the expansion of the repetitions.
Here are the three repetitions specified by the quantifier, combined into a union of path patterns:

[source, role=noheader]
----
(:Stop)-[:NEXT]->(:Stop) |
(:Stop)-[:NEXT]->(:Stop)(:Stop)-[:NEXT]->(:Stop) |
(:Stop)-[:NEXT]->(:Stop)(:Stop)-[:NEXT]->(:Stop)(:Stop)-[:NEXT]->(:Stop)
----

The union operator (`|`) here is used for illustration only; using it this way is not part of Cypher syntax.
Where two node patterns are next to each other in the expansion above, they must necessarily match the same node: the next segment of a `Service` starts where the previous segment ends.
As such they can be rewritten as a single node pattern with any filtering condition combined conjunctively.
In this example this is trivial, because the filtering applied to those nodes is just the label `Stop`:

image::patterns_qpp_illustration.svg[width="400",role="middle"]

With this, the union of path patterns simplifies to:

[source, role=noheader]
----
(:Stop)-[:NEXT]->(:Stop) |
(:Stop)-[:NEXT]->(:Stop)-[:NEXT]->(:Stop) |
(:Stop)-[:NEXT]->(:Stop)-[:NEXT]->(:Stop)-[:NEXT]->(:Stop)
----

The segments of the original path pattern that connect the `Stations` to the `Stops` can also be rewritten.
Here is what those segments look like when concatenated with the first repetition:

[source, role=noheader]
----
(:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(:Stop)
(:Stop)-[:NEXT]->(:Stop)
(:Stop)-[:CALLS_AT]->(:Station { name: 'Clapham Junction' })
----

The original `MATCH` clause now has the following three parts:

image::patterns_qpp_query_breakdown.svg[]

Translating the union of fixed-length path patterns into a quantified path pattern results in a pattern that will return the correct paths.
The following query adds a `RETURN` clause that yields the departure and arrival times of the two services:

.Query
[source, cypher]
----
MATCH (:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(d:Stop)
      ((:Stop)-[:NEXT]->(:Stop)){1,3}
      (a:Stop)-[:CALLS_AT]->(:Station { name: 'Clapham Junction' })
RETURN d.departs AS departureTime, a.arrives AS arrivalTime
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| departureTime | arrivalTime

| "17:10Z" | "17:17Z"
| "17:07Z" | "17:19Z"

2+d|Rows: 2

|===


[[quantified-relationships]]
== Quantified relationships
_This feature was introduced in Neo4j 5.9._

Quantified relationships allow some simple quantified path patterns to be re-written in a more succinct way.
Continuing with the example of `Stations` and `Stops` from the previous section, consider the following query:

.Query
[source,cypher]
----
MATCH (d:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(n:Stop)
      ((:Stop)-[:NEXT]->(:Stop)){1,10}
      (m:Stop)-[:CALLS_AT]->(a:Station { name: 'Clapham Junction' })
WHERE m.arrives < time('17:18')
RETURN n.departs AS departureTime
----

If the relationship `NEXT` only connects `Stop` nodes, the `:Stop` label expressions can be removed:

.Query
[source, cypher]
----
MATCH (d:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(n:Stop)
      (()-[:NEXT]->()){1,10}
      (m:Stop)-[:CALLS_AT]->(a:Station { name: 'Clapham Junction' })
WHERE m.arrives < time('17:18')
RETURN n.departs AS departureTime
----

When the quantified path pattern has one relationship pattern, it can be abbreviated to a _quantified relationship_.
A quantified relationship is a relationship pattern with a postfix quantifier.
Below is the previous query rewritten with a quantified relationship:

.Query
[source, cypher]
----
MATCH (d:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-
        (n:Stop)-[:NEXT]->{1,10}(m:Stop)-[:CALLS_AT]->
        (a:Station { name: 'Clapham Junction' })
WHERE m.arrives < time('17:18')
RETURN n.departs AS departureTime
----

The scope of the quantifier `{1,10}` is the relationship pattern `-[:NEXT]\->` and not the node patterns abutting it.
More generally, where a path pattern contained in a quantified path pattern has the following form:

[source, syntax, role=noheader]
----
(() <relationship pattern> ()) <quantifier>
----

then it can be re-written as follows:

[source, syntax, role=noheader]
----
<relationship pattern> <quantifier>
----

[NOTE]
====
Prior to the introduction of quantified path patterns and quantified relationships in Neo4j 5.9, the only method in Cypher to match paths of a variable length was through variable-length relationships.
This syntax is still available.
It is very similar to the syntax for quantified relationships, with the following differences:

* Position and syntax of quantifier.
* Semantics of the asterisk symbol.
* Type expressions are limited to the xref:patterns/reference.adoc#label-expressions[disjunction operator].
* The xref:clauses/where.adoc[WHERE] clause is not allowed.

For more information, see the reference section on xref:patterns/reference.adoc#variable-length-relationships[variable-length relationships].
====

[[group-variables]]
== Group variables

This section uses the example of `Stations` and `Stops` used in the previous section, but with an additional property `distance` added to the `NEXT` relationships:

image::patterns_group_variables_graph.svg[width="700", role="middle"]

As the name suggests, this property represents the distance between two `Stops`.
To return the total distance for each service connecting a pair of `Stations`, a variable referencing each of the relationships traversed is needed.
Similarly, to extract the `departs` and `arrives` properties of each `Stop`, variables referencing each of the nodes traversed is required.
In this example of matching services between `Denmark Hill` and `Clapham Junction`, the variables `l` and `m` are declared to match the `Stops` and `r` is declared to match the relationships.
The variable origin only matches the first `Stop` in the path:

[source, role=noheader]
----
MATCH (:Station { name: 'Denmark Hill' })<-[:CALLS_AT]-(origin)
      ((l)-[r:NEXT]->(m)){1,3}
      ()-[:CALLS_AT]->(:Station { name: 'Clapham Junction' })
----

Variables that are declared inside quantified path patterns are known as _group variables_.
They are so called because, when referred outside of the quantified path pattern, they are lists of the nodes or relationships they are bound to in the match.
To understand how to think about the way group variables are bound to nodes or relationships, it helps to expand the quantified path pattern, and observe how the different variables match to the elements of the overall matched path.
Here the three different expansions for each value in the range given by the quantifier `{1,3}`:

[source, syntax, role=noheader]
----
(l1)-[r1:NEXT]->(m1) |
(l1)-[r1:NEXT]->(m1)(l2)-[r2:NEXT]->(m2) |
(l1)-[r1:NEXT]->(m1)(l2)-[r2:NEXT]->(m2)(l3)-[r3:NEXT]->(m3)
----

The subscript of each variable indicates which instance of the path pattern repetition they belong to.
The following diagram shows the variable bindings of the path pattern with three repetitions, which matches the service that departs `Denmark Hill` at `17:07`.
It traces the node or relationship that each indexed variable is bound to.
Note that the index increases from right to left as the path starts at `Denmark Hill`:

image::patterns_group_variables_graph2.svg[width="700", role="middle"]

For this matched path, the group variables have the following bindings:

[source, role=noheader]
----
l => [n2, n3, n4]
r => [r2, r3, r4]
m => [n3, n4, n5]
----

The second solution is the following path:

image::patterns_group_variables_graph3.svg[width="700", role="middle"]

The following table shows the bindings for both matches, including the variable origin.
In contrast to the group variables, `origin` is a singleton variable due to being declared outside the quantification.
Singleton variables bind at most to one node or relationship.

[options="header",cols="4*<m"]
|===

| origin | l | r | m

| n2 | [n2, n3, n4] | [r2, r3, r4] | [n3, n4, n5]
| n7 | [n7] | [r8] | [n8]

|===

Returning to the original goal, which was to return the sequence of depart times for the `Stops` and the total distance of each service, the final query exploits the compatibility of group variables with list comprehensions and list functions such as xref::functions/list#functions-reduce[reduce()]:

.Query
[source, cypher]
----
MATCH (:Station {name: 'Denmark Hill'})<-[:CALLS_AT]-(origin)
      ((l)-[r:NEXT]->(m)){1,3}
      ()-[:CALLS_AT]->(:Station {name: 'Clapham Junction'})
RETURN origin.departs + [stop in m | stop.departs] AS departureTimes,
       reduce(acc = 0.0, next in r | round(acc + next.distance, 2)) AS totalDistance
----

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===

| departureTimes | totalDistance

| ["17:10:00Z", "17:20:00Z"] | 1.4
| ["17:07:00Z", "17:11:00Z", "17:13:00Z", "17:20:00Z"] | 1.4

2+d|Rows: 2

|===
